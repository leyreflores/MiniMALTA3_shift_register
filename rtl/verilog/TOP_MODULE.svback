// THE SYNC MEMORY TOP HAS BEEN PUT HERE TO SERVE AS A QUICKSTART



`timescale 1ns / 1ps

// This should be done through an automatic script placed within the globals file. For instance, parse through the modules folder, and for each result create a separate include to be
// pasted in the top file!

`include	"/projects/TOWER180/ALICEITS/IS_OA_588/workAreas/ddobrije/PROJECT/work_libs/user/cds/digital/MiniMALTA_sync_memory_RTL_PORT/rtl/verilog/modules/counters.sv"
`include	"/projects/TOWER180/ALICEITS/IS_OA_588/workAreas/ddobrije/PROJECT/work_libs/user/cds/digital/MiniMALTA_sync_memory_RTL_PORT/rtl/verilog/modules/reset_sync.sv"


// `define INCLUDE_ASYNC_RES 1

// WORK IN PROGRESS






module decoder_gray_2_addr(

	input 	[1:0] i_gray,
	output 	[3:0] o_addr);


	assign  o_addr [0] = ~( i_gray[1] |  i_gray[0]);
	assign  o_addr [1] = ~( i_gray[1] | ~i_gray[0]);
	assign  o_addr [2] = ~(~i_gray[1] | ~i_gray[0]);
	assign  o_addr [3] = ~(~i_gray[1] |  i_gray[0]); 

endmodule


// same concept as above, the NAND function only outputs low (0) if both inputs are set high (1 1).
// Since we are dealing with dual port ram cells, with 4 control terminals (W, W_B, R, R_B)

module decoder_gray_2_addr_B(

	input 	[1:0] i_gray,
	output 	[3:0] o_addr_B);


	assign  o_addr_B [0] = ~(~i_gray[1] & ~i_gray[0]);
	assign  o_addr_B [1] = ~(~i_gray[1] &  i_gray[0]);
	assign  o_addr_B [2] = ~( i_gray[1] &  i_gray[0]);
	assign  o_addr_B [3] = ~( i_gray[1] & ~i_gray[0]); 

endmodule



// ---------------------------------------------------
// Write/Read signal generation
// ---------------------------------------------------

module write_logic
	(
		input 		i_REF,			// This module turns the current write address into a corresponding write signal should there be an incoming
		input 		i_WRITE_EN,		// REF signal, along with the WRITE_EN being high
		input 	[3:0]	i_WRITE_ADDR,
		output	[3:0]	o_WLA,		
		output		o_REF_EN	);

	wire 	[3:0]	WLA_B;				// personal preference, all internal logic iscreated using module limited wires, if they need to be output they will
	wire 	[3:0]	WLA;				// be assigned to an output specific variable in the end.
	wire 		REF_EN;
	genvar 		gi;

	assign REF_EN = i_WRITE_EN & i_REF;


	generate
	for (gi = 0; gi < 4; gi = gi + 1) begin

		assign WLA_B [gi] = ~(REF_EN & i_WRITE_ADDR [gi]);
		assign WLA [gi] = ~WLA_B [gi];

	end
	endgenerate

	assign o_REF_EN = REF_EN;
	assign o_WLA = WLA;

endmodule

module read_logic
	(
		input		i_READ,		// This signal is generated by the priority encoder!
		input	[3:0]	i_READ_ADDR,
		output	[3:0]	o_WLB		);

	wire 	[3:0]	WLB;
	wire	[3:0]	WLB_B;
	genvar		gi;

	generate
	for (gi = 0; gi < 4; gi = gi + 1) begin

		assign WLB_B [gi] = ~(i_READ & i_READ_ADDR [gi]);
		assign WLB [gi] = ~WLB_B [gi];

	end
	endgenerate

	assign o_WLB 	= WLB;

endmodule
	

	


// ====================================================
// Other shit! -------------------------------------
// ====================================================

module hit_check
	(
		input	[3:0]	i_WLA,
		input	[3:0]	i_WLB,
		input		i_HIT_reset,
		output		o_HIT_OR,
		output		o_HIT_AND );

	genvar 		gi;
	reg	[3:0]	HIT;
	wire		HIT_OR;
	wire		HIT_AND;
	wire	[3:0]   HIT_FF_reset;

	generate
	for (gi = 0; gi < 4; gi = gi + 1) begin

		assign HIT_FF_reset [gi] = i_WLB [gi] | ~i_HIT_reset;

		always @ (posedge i_WLA [gi] or posedge HIT_FF_reset [gi]) begin

			if (HIT_FF_reset [gi]) begin
		
				HIT [gi] <= 0;

			end else if (i_WLA [gi]) begin

				HIT [gi] <= 1;

			end
		end
	end

	endgenerate

	assign 	HIT_OR 		= |HIT;	// these are reduction operators!
	assign	HIT_AND		= &HIT;

	assign 	o_HIT_OR 	= HIT_OR;
	assign	o_HIT_AND 	= HIT_AND;

endmodule

// The write enable module is implemented exactly as Ivan's sketch. However, it can probably be done in a simpler way, without the need of assuming negedge triggered resets, etc...
// But leave that for after this actually works.

module write_enable
	(
		input		i_HIT_AND,
		input		i_REF_EN,
		input		i_READ,
		input		i_REF,
		input		i_RST_B,
		output		o_WRITE_EN	);

	reg	ready;
	reg	WRITE_EN;
	wire	write_en_clk;



	
	always @ (negedge i_REF_EN or negedge i_READ) begin		// This FF triggers on one of two negative edges:
									// the REF_EN negedge signifes the end of an incoming word - for instance, the REF signal coming from the matrix stops, 
		if (~i_READ) begin					// which in turn pulls REF_EN down with it. When that happens, the FF passes the 'i_HIT_AND' signal - Should the memory 
									// be still have extra space, this will be a '0'. Otherwise, we pass a 1, which triggers the negedge reset on the 
			ready 	<= 0 ;					// following flip flop - meaning that 'WRITE_EN' goes low, and thus blocks the writing of any incoming 
									// data before the rest has been read out.
		end else begin						// -----------------------

			ready	<= i_HIT_AND;

		end
	end

	assign 	write_en_clk	 = ~(i_REF | i_READ | ~i_RST_B);

	always @ (posedge write_en_clk or posedge ready) begin		// Here, the mentioned 'ready' signal is used to trigger the FF reset, pulling the WRITE_EN down. if we want to enable it again,
									// one of two things needs to happen (apart from the ready signal having to go back down):
		if (ready) begin					// In the case a 'READ' signal is sent from the priority encoder, we can assume a spot in the memory has just been freed up - 
 									// due to this, the sync memory is enabled to write again. However, there is a posibility that incoming data exists just as we 
			WRITE_EN 	<= 0;				// are reading the memory out - In this case, we wish to delay the generation of WRITE_EN so we do not start writing in 
									// the memory cells to soon. In the case there is no read signal, and the reset is till active, the REF signal does nothing. 
		end else begin						// If there is no reset, the REF will continually set WRITE_EN to 1, but in order to do this, the READ signal will 
									// have already set it to 1.
			WRITE_EN	<= 1;				// -----------------------------
									// NOTE: in the case we read out the memory, any hit that arrives at the same time will be discarded. But at the same time, 
									// the WRITE_EN will not get set to 1! so, If there is another hit afterwards, it will also get lost (but will set the WRITE_EN). 
		end							// Perhaps this can be seen a s a safety measure? as this way we contiue writing into the memory only once there are 2 spots free  hit),
									// or (second READ signal comes before the next we skip a few hits before we fill the final memory spot - try experimenting a little bit!
	end

	assign o_WRITE_EN = WRITE_EN;

endmodule

/*
module FAKE_MEMORY
	(
		input		i_REF,					// The 'fake' memory can also be seen as a collection of hit flags - so it does not need to be excluded from the final design
		input	[3:0]	i_WRITE_addr,				// necessarily!
		input	[3:0]	i_READ_addr,				// hold on - isn't this the exact same function done by the hit_and module? the diference is that the other 
		input		i_READ,					// module gets triggered by actual write and read signals (WLA / WLB), which is a far better option.
		output		o_memory);				// TASK: rewrite this module as a non-synthesizeable behavioural model to be used as an intermediate step 
									// between the sync logic and the priority encoder. It can be ignored for now
	reg 	[3:0]	memory;
	genvar		gi;

	generate
	for (gi = 0; gi < 4; gi = gi + 1) begin

		always @ (posedge i_REF or posedge i_READ)

			if (i_WRITE_addr [gi]) begin
		
				memory [gi] <= 1;

			end else if (i_READ_addr [gi]) begin

				memory [gi] <= 0;

			end
		end

	endgenerate

	assign o_memory = memory;
	
	

endmodule
*/

// ========================================================
// TOP MODULE ---------------------------------------------
// ======================================================== 


module sync_memory_TOP (



	input 		I_CLK,
	input		I_CLK_FT,
	input 		I_RST_B,
	input 		I_EN_count,
	input		I_REF,
	input		I_READ,


	output 	[3:0]		O_mem_addr_W,				// these two go straight to the RAM module!
	output 	[3:0]		O_mem_addr_R,
	output 	[1:0]		O_gray_count_W,
	output 	[1:0]		O_gray_count_R,  
	output 	[2:0]		O_gray_count_BC, 
	output 	[4:0]		O_gray_count_FT);

//	---------------------------------



	
	wire			m_REF_EN;
	wire			m_REF_EN_B;
	wire			m_READ_B;
	wire			m_WRITE_EN;
	wire	[1:0]		m_count_W;
	wire	[1:0]		m_count_R;
	wire	[3:0]		m_addr_W;
	wire	[3:0]		m_addr_R;
	wire	[3:0]		m_signal_W;
	wire	[3:0]		m_signal_R;
	wire	[2:0]		m_count_BC;
	wire	[4:0]		m_count_FT;
	wire	[15:0]		m_count_FT_johnson;
	wire	[4:0]		m_count_FT_johnson_gray;

	wire			m_RST_B_FT;
	wire			m_RST_B_FT_alt;
	wire			m_RST_B_FT_alt2;
	wire			m_RST_B;
	wire			m_RST_B_BC;


// Reset logic
// -----------





	
	reset_sync_universal	reset_uni

		(
		.i_CLK		(I_CLK),
		.i_CLK_FT	(I_CLK_FT),
		.i_RST_B	(I_RST_B),
		.o_RST_sync	(m_RST_B),
		.o_RST_sync_BC  (m_RST_B_BC)
		);



// Main logic
// ----------

	write_logic	write_logic_inst

		(
		.i_REF 		(I_REF),
		.i_WRITE_EN	(m_WRITE_EN),			//m_WRITE_EN
		.i_WRITE_ADDR	(m_addr_W),
		.o_WLA		(m_signal_W),
		.o_REF_EN	(m_REF_EN)
		);


	read_logic	read_logic_inst

		(
		.i_READ 	(I_READ),
		.i_READ_ADDR	(m_addr_R),
		.o_WLB		(m_signal_R)
		);


	hit_check	hit_check_inst

		(
		.i_WLA		(m_signal_W),		// m_signal_W/R are signals which propagate to the actual RAM cells. If they get generated (one per each word within the memory)
		.i_WLB		(m_signal_R),		// we can be sure something is getting written/read out. This is why they are good candidates for triggering the memory hit flags.
		.i_HIT_reset	(m_RST_B_BC),		// The 'HIT_OR' signal can be used to tell the priority encoder there is something to be read out, while 'HIT_AND' is used internally as 
		.o_HIT_OR	(m_HIT_OR),		// a sign that all the memory words have been filled out. This could also be sent out to the priority encoder as an indicator that this	
		.o_HIT_AND	(m_HIT_AND)		// sync module should be read out as fast as possible, but this depends more on the possible implementations of the priority encoder than anything else.
		);					


	write_enable	write_enable_inst

		(
		.i_HIT_AND 	(m_HIT_AND),
		.i_REF_EN	(m_REF_EN),
		.i_READ		(I_READ),
		.i_REF		(I_REF),
		.i_RST_B	(m_RST_B_BC),
		.o_WRITE_EN	(m_WRITE_EN)
		);




// Counters (address + timing)
// ---------------------------



	johnson_gray_counter	counter_FT_johnson


		(
		.i_CLK			(I_CLK_FT),
		.i_RST_B		(m_RST_B),
		.i_EN			(I_EN_count),
		.o_count_gray		(m_count_FT)
		);


/*

	johnson_counter	#( .p_timing_width (5) ) counter_FT_johnson

		(
		.i_CLK			(I_CLK_FT),
		.i_RST_B		(m_RST_B),
		.i_EN			(I_EN_count),
		.o_count_johnson	(m_count_FT_johnson)
		);

	johnson_decoder	decoder_FT_johnson

		(
		.i_CLK			(I_CLK_FT),
		.i_RST_B		(m_RST_B),
		.i_count_johnson	(m_count_FT_johnson),
		.o_count_gray		(m_count_FT_johnson_gray)
		);
*/
/*
	gray_counter	#( .p_num_bits (5) ) 	counter_FT

		(
		.i_CLK		(I_CLK_FT),
		.i_RST		(I_RST_B),
		.i_EN		(I_EN_count),
		.o_count_gray	(m_count_FT)
		);
*/
	gray_counter  	#( .p_num_bits (3) ) 	counter_BC

		(
		.i_CLK		(I_CLK),
		.i_RST_B	(m_RST_B_BC),
		.i_EN		(I_EN_count),
		.o_count_gray	(m_count_BC)
		);

	gray_counter_async_res  	#( .p_num_bits (2) ) 	counter_ADDR_W

		(
		.i_CLK		(m_REF_EN_B),			// If there is a REF_EN signal that goes low, that means that a write cycle has just been finished (or attempted)
		.i_RST_B	(m_RST_B_BC),			// By triggering on the positive edge of the inverted signal, we do exactly that. 
		.i_EN		(I_EN_count),			// (the counter was implemented expecting a positive clock)
		.o_count_gray	(m_count_W)
		);

	gray_counter_async_res  	#( .p_num_bits (2) ) 	counter_ADDR_R

		(
		.i_CLK		(m_READ_B),			// Similar logic as above, but we wait for the end of the READ signal.
		.i_RST_B	(m_RST_B_BC),
		.i_EN		(I_EN_count),
		.o_count_gray	(m_count_R)
		);


// Address decoders
// ----------------


	decoder_gray_2_addr 	decoder_W

		(
		.i_gray		(m_count_W),
		.o_addr		(m_addr_W)
		);


	decoder_gray_2_addr 	decoder_R

		(
		.i_gray		(m_count_R),
		.o_addr		(m_addr_R)
		);


/*
	decoder_gray_2_addr_B 	decoder_B

		(
		.i_gray		(m_addr_count),
		.o_addr_B	(O_mem_addr_B)
		);
*/

	assign m_REF_EN_B	= ~m_REF_EN;
	assign m_READ_B		= ~I_READ;

// Output assignments:
// ------------------


	assign O_mem_addr_W			= m_addr_W;
	assign O_mem_addr_R			= m_addr_R;
	assign O_gray_count_W			= m_count_W;
	assign O_gray_count_R			= m_count_R;
	assign O_gray_count_BC			= m_count_BC;
	assign O_gray_count_FT			= m_count_FT;		
		


	

	

endmodule
